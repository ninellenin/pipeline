package pipeline.runtime;

/*Generated by MPS */

import java.util.concurrent.ConcurrentLinkedQueue;

public class MergeTokens extends Filter<TokenItem, SentenceItem> {
  private Filter<?, TokenItem> input;
  private ConcurrentLinkedQueue<SentenceItem> output;

  public MergeTokens(Filter<?, TokenItem> input) {
    this.input = input;
    output = new ConcurrentLinkedQueue<SentenceItem>();
  }

  @Override
  public void run() {
    input.start();
    TokenItem item = input.getItem();
    StringBuilder builder = new StringBuilder();

    while (!((item.getState() == Item.State.KEY_WORD && item.getValue().equals(TextItem.END_OF_TEXT)))) {
      if (item.isBeginOfText()) {
        output.add(new SentenceItem(item.getState(), item.getValue()));
      } else if (item.getState() != Item.State.EMPTY) {
        if (item.getState() == Item.State.STR) {
          builder.append(" " + item.getValue());
        } else if (item.getState() == Item.State.KEY_WORD && item.getValue().equals(SentenceItem.END_OF_SENTENCE)) {
          output.add(new SentenceItem(Item.State.STR, builder.toString()));
          output.add(new SentenceItem(Item.State.KEY_WORD, SentenceItem.END_OF_SENTENCE));
          builder = new StringBuilder();
        } else {
          output.add(new SentenceItem(item.getState(), item.getValue()));
        }
      }
      item = input.getItem();
    }
    System.out.println("MergeText finished.");
    output.add(new SentenceItem(Item.State.KEY_WORD, TextItem.END_OF_TEXT));
  }
  @Override
  public SentenceItem getItem() {
    SentenceItem item = output.poll();
    if (item == null) {
      return new SentenceItem(Item.State.EMPTY, null);
    } else {
      return item;
    }
  }
}
