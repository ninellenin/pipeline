package pipeline.runtime;

/*Generated by MPS */

import java.util.concurrent.ConcurrentLinkedQueue;

public class MergeSentences extends Filter<SentenceItem, TextItem> {
  private Filter<?, SentenceItem> input;
  private ConcurrentLinkedQueue<TextItem> output;

  public MergeSentences(Filter<?, SentenceItem> input) {
    this.input = input;
    output = new ConcurrentLinkedQueue<TextItem>();
  }

  @Override
  public void run() {
    input.start();
    SentenceItem item = input.getItem();
    StringBuilder builder = new StringBuilder();

    while (!((item.getState() == Item.State.KEY_WORD && item.getValue().equals(TextItem.END_OF_TEXT)))) {
      if (item.isBeginOfText()) {
        output.add(new TextItem(item.getState(), item.getValue()));
      } else if (item.getState() != Item.State.EMPTY) {
        if (item.getState() == Item.State.STR) {
          builder.append(item.getValue());
        }
        if (item.getState() == Item.State.KEY_WORD && item.getValue() == SentenceItem.END_OF_SENTENCE) {
          builder.append(". ");
        }
      }
      item = input.getItem();
    }
    System.out.println("MergeText finished.");
    output.add(new TextItem(Item.State.STR, builder.toString()));
    output.add(new TextItem(Item.State.KEY_WORD, TextItem.END_OF_TEXT));
  }

  @Override
  public TextItem getItem() {
    TextItem item = output.poll();
    if (item == null) {
      return new TextItem(Item.State.EMPTY, null);
    } else {
      return item;
    }
  }
}
